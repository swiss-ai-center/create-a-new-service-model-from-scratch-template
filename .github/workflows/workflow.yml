# Documentation: https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstepsuses
name: github_worflow
run-name: GitHub Workflow

env:
  # Service name (must be lowercase and not contain any spaces)
  # Note: The files in model-serving/kubernetes/ must be named accordingly
  SERVICE_NAME: sample-service
  # Organization name (must be lowercase and not contain any spaces)
  # The organization name is used to build the Docker image name. It can be changed to your liking but usually it is the same as the GitHub organization name or username
  ORGANIZATION_NAME: sample-organization
  # The URLs of the Core Engine to which the service (dev) should connect
  DEV_CORE_ENGINE_URLS: "'[\"https://dev-core-engine.example.com\"]'"
  # The URLs of the Core Engine to which the service (prod) should connect
  PROD_CORE_ENGINE_URLS: "'[\"https://core-engine.example.com\"]'"
  # The URL that the service (dev) should be accessible at
  DEV_SERVICE_URL: https://dev-my-service.example.com
  # The URL that the service (prod) should be accessible at
  PROD_SERVICE_URL: https://my-service.example.com
  # The Kubernetes namespace that the service (dev) should be deployed to
  DEV_NAMESPACE: dev
  # The Kubernetes namespace that the service (prod) should be deployed to
  PROD_NAMESPACE: prod

# Allow one concurrent deployment
concurrency:
  group: github_worflow
  cancel-in-progress: true

on:
  push:
    branches:
      - main
      - prod

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

jobs:
  review:
    runs-on: ubuntu-latest
    steps:
      - name: Clone repository
        uses: actions/checkout@v3

      - name: Lint Python app
        uses: swiss-ai-center/common-code/actions/lint-python-app@main
        with:
          python-app-path: ./model-serving

  train:
    needs: review
    runs-on: ubuntu-latest
    steps:
      - name: Clone repository
        uses: actions/checkout@v3

      - name: Run ML experiment with DVC
        uses: swiss-ai-center/common-code/actions/run-ml-experiment-with-dvc@main
        with:
          ml-experiment-path: ./model-creation
          s3-access-key-id: ${{ secrets.SERVICE_S3_ACCESS_KEY_ID }}
          s3-secret-access-key: ${{ secrets.SERVICE_S3_SECRET_ACCESS_KEY }}

      - name: Upload model
        uses: actions/upload-artifact@v3
        with:
          name: model
          # TODO: 3. CHANGE THE PATH TO THE MODEL
          path: ./model-creation/path_to_model
          retention-days: 5

  test:
    needs: train
    runs-on: ubuntu-latest
    steps:
      - name: Clone repository
        uses: actions/checkout@v3

      - name: Download model
        uses: actions/download-artifact@v3
        with:
          name: model
          path: ./model-serving

      - name: Test Python app
        uses: swiss-ai-center/common-code/actions/test-python-app@main
        with:
          python-app-path: ./model-serving
          token: ${{ secrets.GITHUB_TOKEN }}

  release:
    needs: test
    runs-on: ubuntu-latest
    # Only run on main
    if: success() && github.ref == 'refs/heads/main'
    steps:
      - name: Clone repository
        uses: actions/checkout@v3

      - name: Download model
        uses: actions/download-artifact@v3
        with:
          name: model
          path: ./model-serving

      - name: Build and push Docker image to GitHub
        id: build-and-push-docker-image-to-github
        uses: swiss-ai-center/common-code/actions/build-and-push-docker-image-to-github@main
        with:
          docker-registry-username: ${{ github.actor }}
          docker-registry-password: ${{ secrets.GITHUB_TOKEN }}
          docker-image-name: ${{ env.ORGANIZATION_NAME }}/${{ env.SERVICE_NAME }}
          docker-image-context: ./model-serving
    outputs:
      docker-image-tags: ${{ steps.build-and-push-docker-image-to-github.outputs.docker-image-tags }}

  deploy-dev:
    needs: release
    runs-on: ubuntu-latest
    # Only run on main and if secret DEPLOY_DEV is set to true
    if: success() && github.ref == 'refs/heads/main' && secrets.DEPLOY_DEV == 'true'
    steps:
      - name: Clone repository
        uses: actions/checkout@v3

      - name: Prepare configuration files
        shell: bash
        working-directory: ./model-serving/kubernetes
        env:
          ENVIRONMENT: development
          LOG_LEVEL: info
          ENGINE_URLS: ${{ env.DEV_CORE_ENGINE_URLS }}
          SERVICE_URL: ${{ env.DEV_SERVICE_URL }}
        run: |
          # Set service version
          docker_image_tags=(${{ needs.release.outputs.docker-image-tags }})
          docker_image_sha_tag="${docker_image_tags[1]}"
          yq ".spec.template.spec.containers[0].image = \"$docker_image_sha_tag\"" service.stateful.yml > new-service.stateful.yml && mv new-service.stateful.yml service.stateful.yml

          # Set service configuration (ConfigMap)
          yq '.data = (.data | to_entries | map({"key": .key, "value": "${" + .key + "}"}) | from_entries)' service.config-map.yml | envsubst > new-service.config-map.yml && mv new-service.config-map.yml service.config-map.yml

          # Set service configuration (Ingress)
          yq ".metadata.name = \"${{ env.SERVICE_NAME }}\"" service.ingress.yml > new-service.ingress.yml && mv new-service.ingress.yml service.ingress.yml
          yq ".spec.rules[0].host = \"${SERVICE_URL#*://}\"" service.ingress.yml > new-service.ingress.yml && mv new-service.ingress.yml service.ingress.yml
          yq ".spec.tls[0].hosts[0] = \"${SERVICE_URL#*://}\"" service.ingress.yml > new-service.ingress.yml && mv new-service.ingress.yml service.ingress.yml

          # Set service configuration (Service)
          yq ".metadata.name = \"${{ env.SERVICE_NAME }}-service\"" service.service.yml > new-service.service.yml && mv new-service.service.yml service.service.yml
          yq ".spec.selector.app = \"${{ env.SERVICE_NAME }}\"" service.service.yml > new-service.service.yml && mv new-service.service.yml service.service.yml

          # Set service configuration (StatefulSet)
          yq ".metadata.name = \"${{ env.SERVICE_NAME }}-stateful\"" service.service.yml > new-service.service.yml && mv new-service.service.yml service.service.yml
          yq ".metadata.labels.app = \"${{ env.SERVICE_NAME }}\"" service.service.yml > new-service.service.yml && mv new-service.service.yml service.service.yml
          yq ".spec.serviceName = \"${{ env.SERVICE_NAME }}\"" service.service.yml > new-service.service.yml && mv new-service.service.yml service.service.yml
          yq ".spec.selector.matchLabels.app = \"${{ env.SERVICE_NAME }}\"" service.service.yml > new-service.service.yml && mv new-service.service.yml service.service.yml
          yq ".spec.template.metadata.labels.app = \"${{ env.SERVICE_NAME }}\"" service.service.yml > new-service.service.yml && mv new-service.service.yml service.service.yml
          yq ".spec.template.spec.containers[0].name = \"${{ env.SERVICE_NAME }}\"" service.service.yml > new-service.service.yml && mv new-service.service.yml service.service.yml
          yq ".spec.template.spec.containers[0].image = \"$docker_image_sha_tag\"" service.service.yml > new-service.service.yml && mv new-service.service.yml service.service.yml
          yq ".spec.template.spec.containers[0].envFrom[0].configMapRef.name = \"${{ env.SERVICE_NAME }}-config\"" service.service.yml > new-service.service.yml && mv new-service.service.yml service.service.yml

      - name: Deploy ${{ env.SERVICE_NAME }} on the Kubernetes cluster
        uses: swiss-ai-center/common-code/actions/execute-command-on-kubernetes-cluster@main
        with:
          kube-config: ${{ secrets.KUBE_CONFIG_DEV }}
          kube-namespace: ${{ env.DEV_NAMESPACE }}
          kubectl-context: ./model-serving/kubernetes
          kubectl-args: |
            apply \
              -f service.config-map.yml \
              -f service.stateful.yml \
              -f service.service.yml \
              -f service.ingress.yml

  deploy-prod:
    needs: release
    runs-on: ubuntu-latest
    # Only run on prod and if secret DEPLOY_PROD is set to true
    if: success() && github.ref == 'refs/heads/prod' && secrets.DEPLOY_PROD == 'true'
    steps:
      - name: Clone repository
        uses: actions/checkout@v3

      - name: Prepare configuration files
        shell: bash
        working-directory: ./model-serving/kubernetes
        env:
          ENVIRONMENT: production
          LOG_LEVEL: info
          ENGINE_URLS: ${{ env.PROD_CORE_ENGINE_URLS }}
          SERVICE_URL: ${{ env.PROD_SERVICE_URL }}
        run: |
          # Set service version
          docker_image_tags=(${{ needs.release.outputs.docker-image-tags }})
          docker_image_sha_tag="${docker_image_tags[1]}"
          yq ".spec.template.spec.containers[0].image = \"$docker_image_sha_tag\"" service.stateful.yml > new-service.stateful.yml && mv new-service.stateful.yml service.stateful.yml

          # Set service configuration (ConfigMap)
          yq '.data = (.data | to_entries | map({"key": .key, "value": "${" + .key + "}"}) | from_entries)' service.config-map.yml | envsubst > new-service.config-map.yml && mv new-service.config-map.yml service.config-map.yml

          # Set service configuration (Ingress)
          yq ".spec.rules[0].host = \"${SERVICE_URL#*://}\"" service.ingress.yml > new-service.ingress.yml && mv new-service.ingress.yml service.ingress.yml
          yq ".spec.tls[0].hosts[0] = \"${SERVICE_URL#*://}\"" service.ingress.yml > new-service.ingress.yml && mv new-service.ingress.yml service.ingress.yml

      - name: Deploy ${{ env.SERVICE_NAME }} on the Kubernetes cluster
        uses: swiss-ai-center/common-code/actions/execute-command-on-kubernetes-cluster@main
        with:
          kube-config: ${{ secrets.KUBE_CONFIG_PROD }}
          kube-namespace: ${{ env.PROD_NAMESPACE }}
          kubectl-context: ./model-serving/kubernetes
          kubectl-args: |
            apply \
              -f service.config-map.yml \
              -f service.stateful.yml \
              -f service.service.yml \
              -f service.ingress.yml
